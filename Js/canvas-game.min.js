/*Jcerelus Dev All Rights Reserved.
Developper : Jean .F CÉRÉLUS
canvasgameJs is a javascript canvas library, 
that makes you develop game very  quick
all of the work is done behind the scene.
*/
// grab dom element
var particles = new Array()
var snows = []
var rains = []
var camera
var pathIndex = 0
var isLight = false
var light
get = function (x) {
  return document.querySelector(x)
}

getAll = function (x) {
  return document.querySelectorAll(x)
}

var reqA

var imSet = false
var JumpTime = 0

var SPEED
var friction = 0.5
var isCamera = false
var tileAnimation
var objframe = 0
var layerframe = 0
var saveBg;
var frame = 0
var delta
var isFake = false
//Developper : Jean .F CÉRÉLUS
// short cut console.log
const log = console.log

//Main Method
var self
var rotImage = false
var isOnAir = false
var onFloor = false
var toJson = JSON.stringify
var ctx;

function Stage() {

  self = {
    // create stage
    stage: document.createElement("canvas"),
  }


  if (self.scale == undefined) {
    self.scale = 1
  }


  self.stage.style.position = "absolute"
  self.stage.style.zIndex = 0
  self.stage.style.imageRendering = "pixelated"
  self.stage.style.background = "white"





  // add  to the document
  self.add = function (x, b) {
    this.b = b
    if (b == undefined) {
      document.body.appendChild(x)

    }




    if (b !== undefined && b == "before") {
      document.body.before(x)

    }

  }

  // remove from the document
  self.delete = function (x) {
    document.body.removeChild(x)
  }



  //set stage background
  var saveBg
  self.stage.setBg = function (c) {

    this.c = c
    if (isFake) {
      saveBg = this.c || "transparent"
    }

    if (this.c == undefined || c == undefined || this.c == "") {
      self.stage.style.background = saveBg
    }
    else if (isFake && this.c == undefined || c == undefined || this.c == "") {
      self.stage.style.background = "transparent"
    } else if (this.c && !isFake) {
      saveBg = this.c
      self.stage.style.background = saveBg

    } if (this.c == undefined && !isFake) {
      saveBg = "rgba(17,34,51,0.8)"
      self.stage.style.background = saveBg
    }
  }




  // set the size of the stage
  self.setSize = function (a, b) {
    this.a = a * self.scale; this.b = b * self.scale / 1.5


    if (this.a && this.b) {
      gW = self.stage.width = this.a
      gH = self.stage.height = this.b
    }

  }


  if (this.a == undefined && this.b == undefined) {
    gW = self.stage.width = 600
    gH = self.stage.height = 400
  }



  camera = { x: 1, y: 1, width: gW, height: gH };

  //Developper : Jean .F CÉRÉLUS
  // set the background color of the  stage 
  /*self.stage.setBg = function(c){
  this.c = c
   self.stage.style.background = c
  }
  */


  //Developper : Jean .F CÉRÉLUS
  // set the background repeat 
  self.stage.setBgRepeat = function (x) {
  }

  self.stage.style.imageRendering = "pixelated"

  // grab context for the stage

  ctx = self.stage.getContext("2d")



  // fill your canvas drawing with color
  rectColor = function (x) {
    ctx.fillStyle = x
  }

  // stroke your canvas drawing with color
  strokeColor = function (x) {
    ctx.strokeStyle = x
  }



  // fill your canvas  
  Rect = function (a, color = a.color) {
    ctx.fillStyle = color
    ctx.fillRect(a.x, a.y, a.w, a.h)
  }

  //Developper : Jean .F CÉRÉLUS
  // stroke your canvas 
  Stroke = function (a, color = a.color) {
    ctx.strokeStyle = color
    ctx.strokeRect(a.x, a.y, a.w, a.h)
  }


// getObjectLayer

self.getObjectLayer = function(layerName){
  for(layer of data.layers){
     if(layer.type=="tilelayer"){
       continue
     }
      if(layer.name == layerName ){
        return layer.objects
      }
  
  }
  
  return layer
}


  //Overlay

  self.overLay = function () {
    opacity = 1
    self.stage.style.zIndex = -999
    var box = document.createElement("canvas")
    document.body.appendChild(box);
    box.style.width = gW + "px"
    box.style.height = gH + "px"
    box.style.position = "absolute"
    box.style.zIndex = 99999

    box.style.background = `rgba(0,0,0,${opacity})`


    setTimeout(function () {
      opacity -= 0.02
      box.style.background = `rgba(0,0,0,${opacity})`
    }, 300)
    setTimeout(function () {
      opacity -= 0.04
      box.style.background = `rgba(0,0,0,${opacity})`
    }, 600)
    setTimeout(function () {
      opacity -= 0.06
      box.style.background = `rgba(0,0,0,${opacity})`
    }, 900)

    setTimeout(function () {
      opacity -= 0.08
      box.style.background = `rgba(0,0,0,${opacity})`
    }, 1000)

    setTimeout(function () {
      opacity -= 0.2
      box.style.background = `rgba(0,0,0,${opacity})`
    }, 1200)

    setTimeout(function () {
      opacity -= 0.04
      box.style.background = `rgba(0,0,0,${opacity})`
    }, 1400)

    setTimeout(function () {
      opacity = 0
      box.style.background = `rgba(0,0,0,${opacity})`
    }, 1500)

  }



  // light

  self.light = function (obj, radius, opacity) {
    isLight = true
    this.obj = obj
    this.radius = radius
    this.opacity = opacity
    light = { x: this.obj.x + this.obj.w / 2, y: this.obj.y + this.obj.h / 2, r: this.radius, opacity: this.opacity }

    return this
  }

  // play sound

  playSound = function (x) {
    this.audio = new Audio(x)
    this.audio.currentTime = 0
    this.audio.volume = 0.2;
    this.audio.play()

    return this
  }

  stopSound = function (x) {
    x.currentTime = 0
    x.audio.pause()


  }

  //Developper : Jean .F CÉRÉLUS


  // draw text method
  Text = function (color, fontstyle, fontsize, fontfamily, t, x, y) {
    this.x = x
    this.y = y
    this.color = color || "gold"
    this.fontsize = fontsize
    this.fontstyle = fontstyle
    /*this.fontweight = fontweight*/
    this.fontfamily = fontfamily
    this.t = t

    // if not define by the developer
    if (this.fontweight == undefined) {
      this.fontweight = "bold"
    }

    //Developper : Jean .F CÉRÉLUS

    if (this.fontstyle == undefined) {
      this.fontstyle = "italic"
    }

    if (this.fontfamily == undefined || this.fontfamily == null) {
      this.fontfamily = "monospace"
    }


    ctx.fillStyle = this.color
    ctx.font = this.fontstyle + " " + this.fontsize + " " + this.fontfamily
    ctx.fillText(this.t, this.x, this.y)

  }


  // Clear the stage 
  clear = function (x, y, w, h) {
    ctx.clearRect(x, y, w, h)
  }

  //Developper : Jean .F CÉRÉLUS



  //get distance
  self.getDistance = function (a, b) {
    this.a = a
    this.b = b
    var dx = Math.abs(this.a.x - this.b.x)
    var dy = Math.abs(this.a.y - this.b.y)
    var length = Math.hypot(dx, dy)
    return length

  }


  //get angle
  self.getAngle = function (a, b) {
    this.a = a
    this.b = b
    var angle = Math.atan2(this.a.y - this.b.y, this.a.x - this.b.x)
    return angle

  }


  self.isClosest = function (obj1, obj2) {
    return distance = self.getDistance(obj1, obj2)

  }


  // add boxCollider

  self.setCollider = function (obj, isVisible) {
    obj.isVisible = isVisible
    if (typeof (isVisible) != "boolean") return

    if (obj.sw >= 100 || obj.sh >= 100) {
      obj.collider = {
        x: obj.x + obj.w / 2.3,
        y: obj.y + obj.h / 2.8,
        w: obj.w / 8,
        h: obj.h / 4,
        color: "rgba(255,0,0,0.5)"
      }
    }

    else {

      obj.collider = {
        x: obj.x + obj.w / 4.5,
        y: obj.y + obj.h / 4.5,
        w: obj.w / 3.7,
        h: obj.h - 9,
        vy: obj.vy,
        color: "rgba(255,0,0,0.5)"
      }
      
      if(obj.sh > obj.sw){
         obj.collider = {
         x: obj.x + obj.w / 4,
         y: obj.y + obj.h / 4.8,
         w: obj.w / 2.5,
         h: obj.h - 5,
         vy: obj.vy,
         color: "rgba(255,0,0,0.5)"
         }
         
         if(obj.flipX){
           obj.collider.x = obj.x+obj.w/4
         
         }
      
      }
      


      if (!obj.image) {
        obj.collider = {
          x: obj.x + obj.w / 4,
          y: obj.y,
          w: obj.w - 10,
          h: obj.h,
          vy: obj.vy,
          color: "rgba(255,0,0,0.5)"
        }


      }


    }
  }





  // handle camera with limit


  var cameraSet = false

  self.setCam = function (obj, world, debug) {



    if (self.scale == 1) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (self.scale == 1.1) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (self.scale == 1.2) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (self.scale == 1.3) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (self.scale == 1.4) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }


    if (self.scale == 1.5) {
      camera = { x: 0, y: 0, width: (gW / self.scale) | 0, height: (gH / self.scale) | 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (self.scale == 1.6) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (self.scale == 1.7) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (self.scale == 1.8) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }


    if (self.scale == 1.9) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }


    if (self.scale == 2) {
      camera = { x: 0, y: 0, width: (gW / self.scale) >> 0, height: (gH / self.scale) >> 0, color: "red" }
      x = ((camera.width / 2) + obj.w / 2) >> 0
      y = ((camera.height / 2) + obj.h / 2) >> 0

    }

    if (world == undefined) {
      ctx.translate((gW / 2 - (obj.x - 5)) >> 0, ((gH / 2) - (obj.y - 5)) >> 0)

      return
    }


    this.debug = debug

    if (this.debug && typeof (this.debug) == "boolean") {
      cameraSet = true
    }


    camera.x = (obj.x + obj.w) - x
    camera.y = (obj.y + obj.h) - y

    if (camera.x <= 0) {
      camera.x = 0
    }

    if (camera.y <= 0) {
      camera.y = 0
    }


    if (camera.x >= world.width - camera.width) {
      camera.x = world.width - camera.width
    }

    if (camera.y > world.height - camera.height) {
      camera.y = world.height - camera.height
    }

    if (obj.x + camera.width * self.scale >= x) {
      ctx.translate(((-camera.x) * self.scale) | 0, 0)
      isCamera = true
    }

    if (obj.y + camera.height * self.scale >= y) {
      ctx.translate(0, ((-camera.y) * self.scale) | 0)
      isCamera = true
    }

    if (obj.x < x) {
      isCamera = false
    }

    if (obj.y < y) {
      isCamera = false
    }




  }



  // end of camera with limit


  //game Loop


    var then , fpsInterval
    self.setAnimation = function (fps) {
      then = 0
      fpsInterval = 1000/ fps
    reqA = requestAnimationFrame(gameLoop)

  }


  self.stopAnimation = function () {
    cancelAnimationFrame(reqA)
  }


  var secondPassed


  function gameLoop(time) {
    clear(0, 0, gW, gH)
    reqA = requestAnimationFrame(gameLoop)
    now = time


    frame++

    if (frame % 4 === 0 && isLayer) {
      layerframe++
      frame = 0
    }

    if (frame % 4 === 0 && isObject) {
      objframe++
      frame = 0
    }



    deltaTime =  now - then
      if (deltaTime > fpsInterval) {
         delta = (deltaTime/1000).toFixed(3)
      
       then = time - (deltaTime % fpsInterval )
       self.update(delta)
      }

    self.stage.style.imageRendering = 'pixelated';
    ctx.imageSmoothingEnabled = false;
    ctx.imageSmoothingQuality = "high"


    self.stage.style.imageRendering = "pixelated"

    self.stage.setBg(saveBg)
    if (!isFake) {
      self.stage.setBg(saveBg)
    }

    ctx.save()
    if (isLight) {
      ctx.fillStyle = "transparent"//rgb(35,35,35)"
      ctx.fillRect(0, 0, gW, gH)
    } else if (!isLight) {
      ctx.fillStyle = saveBg
      ctx.fillRect(0, 0, gW, gH)

    }


    if (!self.drawGame) {
      self.render()
    } else {
      self.drawGame()
    }

    particles.forEach(function (particle) {
      particle.update()

      particle.draw()

    })


    snows.forEach(function (snow, i) {
      if (canDraw(snow, camera)) {
        ctx.beginPath()
        ctx.fillStyle = snow.color
        ctx.arc(snow.x, snow.y += snow.vy, snow.r, 1.8, Math.PI * 1.7)
        ctx.fill()
        ctx.closePath()

      } else {
        kill(snows, i)

      }

    })


    for (rain of rains) {
      var index = rains.indexOf(rain)
      ctx.save()

      if (canDraw(rain, camera)) {
        rain.drawSprite()

      } else {
        kill(rains, index)
      }
      ctx.restore()

    }


    if (isLight) {
      cv = document.createElement("canvas")

      cv.width = gW
      cv.height = gH
      cv.style.position = "absolute"


      ctx.save()
      ctx.beginPath()
      ctx.fillStyle = "rgba(255,255,255,0.35)"
      ctx.globalCompositeOperation = "lighter"
      ctx.arc(light.x * self.scale, light.y * self.scale, light.r, 0, 2 * Math.PI);
      ctx.fill();
      ctx.closePath()
      ctx.restore()

      ctx.fillStyle = `rgba(0,0,0,${light.opacity})`

      ctx.globalCompositeOperation = "overlay"
      ctx.fillRect(camera.x * self.scale, camera.y * self.scale, cv.width, cv.height)

      ctx.drawImage(cv, 0, 0)


    }




    if (cameraSet) {
      ctx.strokeStyle = camera.color
      ctx.lineWidth = self.scale * 2
      ctx.strokeRect((camera.x) * self.scale, camera.y * self.scale, (camera.width) * self.scale, camera.height * self.scale)


    }

    ctx.restore()

  }




  kill = function (arr, index) {
    return arr.splice(index, 1)

  }


  self.isHoriBorder = function (a, b) {

    if (a.r == undefined && b.x == undefined) {
      if (a.x <= 0 || a.x >= b.width - a.w || a.x >= b.w - a.w) {
        return true
      }
    }


    else if (a.r == undefined && b.x !== undefined) {
      if (a.x <= b.x || a.x >= b.width - a.w || a.x >= b.w - a.w) {

        return true
      }
    }

    else if (a.r != undefined && b.x != undefined) {
      if (a.x <= b.x || a.x >= b.width - a.r || a.x >= b.w - a.r) {
        return true
      }

    }


    else if (a.r != undefined && b.x == undefined) {
      if (a.x <= 0 || a.x >= b.width - a.r || a.x >= b.w - a.r) {

        return true
      }

    }

  }



  self.isVertiBorder = function (a, b) {
    if (a.r == undefined && b.x !== undefined) {
      if (a.y <= b.y || a.y >= b.height - a.h || a.y >= b.h - a.h) {
        return true
      }
    }

    //Developper : Jean .F CÉRÉLUS
    else if (a.r != undefined && b.y !== undefined) {
      if (a.y <= b.y || a.y >= b.height - a.r || a.x >= b.h - a.r) {
        return true
      }

    }


    if (a.r == undefined && b.y == undefined) {
      if (a.y <= 0 || a.y >= b.height - a.h || a.y >= b.h - a.h) {
        return true
      }
    }

    //Developper : Jean .F CÉRÉLUS
    else if (a.r != undefined && b.y == undefined) {
      if (a.y <= 0 || a.y >= b.height - a.r || a.x >= b.h - a.r) {
        return true
      }

    }

  }
  
  // preventOverlapping
  self.preventOverlapping = function(arr) {
  for (let i = 0; i < arr.length; i++) {
  const group1 = arr[i];
  
  for (let j = 0; j < arr.length; j++) {
  const group2 = arr[j];
  
  if (group1.checkCollision(group2)) {
  kill(arr, i);
  kill(arr,j);

  
  // Adjust the index to account for the removed enemies
  if (j > i) {
    j--;
  }
  return
  }

  }
  }
  }
  
  
  
  
  return self
}


// deg2Rad to handle rotation
var Deg2Rad = Math.PI / 180;


//createLine
class Line {
  constructor(x1, x2, y1, y2, color, width) {
    this.x1 = x1
    this.x2 = x2
    this.y1 = y1
    this.y2 = y2
    this.color = color
    this.width = width
    this.vx = 0
    this.vy = 0
  }

  drawLine() {
    ctx.beginPath()
    ctx.strokeStyle = this.color
    ctx.moveTo(this.x1, this.y1)
    ctx.lineTo(this.x2, this.y2)
    ctx.lineWidth = this.width
    ctx.stroke()
    ctx.closePath()

  }

  updateLine() {
    this.x2 += this.vx * delta
    this.y2 += this.vy * delta

  }

}


//create polygons

function PolyGons(startX, startY, sides, radius, color, angle, speedX, speedY,fill) {
  this.startX = startX;
  this.startY = startY;
  this.sides = sides;
  this.radius = radius;
  this.angle = angle || 0;
  this.color = color;
  this.speedX = speedX || 0;
  this.speedY = speedY || 0;
  this.fill = fill || false
  this.type = "polygon"
  this.alpha = 1
  if(typeof(this.fill) != "boolean"){
    ("fill must be a boolean ")
    return
  }
  
  this.bullet = []
this.draw = function () {
   drawPolyBullet(this)
  ctx.beginPath();
  ctx.moveTo(
    this.startX + this.radius  * Math.cos(0 + this.angle),
    this.startY + this.radius * Math.sin(0 + this.angle)
  );

  for (var i = 1; i <= this.sides; i++) {
    if (this.sides == 3 && this.flipX) {
      this.currentAngle =
        1 - ((i * (Math.PI * 2)) / this.sides + this.angle);
    } else {
      this.currentAngle = ((i * (Math.PI * 2)) / this.sides + this.angle);
    }

    if (!this.fill) {
      this.x = this.startX + this.radius  * Math.cos(this.currentAngle);
      this.y = this.startY + this.radius * Math.sin(this.currentAngle);
   
    
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      ctx.lineTo(this.x, this.y);
      ctx.stroke();
    } else if (this.fill) {
      this.x = this.startX + this.radius *  Math.cos(this.currentAngle);
      this.y = this.startY + this.radius * Math.sin(this.currentAngle);
      if(this.alpha != 1){
        ctx.globalAlpha = this.alpha
       }else{
       ctx.globalAlpha = this.alpha
       }
      ctx.fillStyle = this.color;
      ctx.lineTo(this.x, this.y);
      ctx.fill();
      
    }
  }
  
  // Connect the last point back to the starting point
  ctx.lineTo(
    this.startX + this.radius  * Math.cos(0 + this.angle),
    this.startY + this.radius * Math.sin(0 + this.angle)
  );
  
  // Stroke or fill the shape
  if (!this.fill) {
     if(this.alpha != 1){
     ctx.globalAlpha = this.alpha
     }else{
     ctx.globalAlpha = this.alpha
     }
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 1.5;
    ctx.stroke();
  } else if (this.fill) {
    
    ctx.fillStyle = this.color;
    ctx.fill();
  }
     
     ctx.closePath()
  };

  this.update = function () {
    this.startX += this.speedX;
    this.startY += this.speedY;
    if (this.angle > 0) this.angle += 0.01;
    
  };
  
  
  this.addBullet = function (x, y, w, h, color, r, angle) {
    this.obj = {
      x: x,
      y: y,
      w: w,
      h: h,
      color: color,
      r: r,
      angle: angle,
      direction: this.direction
  
  
    }
  
  
    if (this.obj.direction || this.obj.angle) {
      this.bullet.push(this.obj)
    }
    
    
    // bullet durection direction
    
    this.direction = function () {
    
    
    if (this.speedX > 0 ) {
    return 1
    }
    
    if (this.speedX < 0) {
    return - 1
    }
    
    if (this.speedY > 0) {
    this.speedX = 0
    return 2
    }
    
    if (this.speedY < 0) {
    return - 2
    }
    
    
    }
  
  }

  this.checkCollision = function (otherPolygon) {
    var dx = this.startX - otherPolygon.startX;
    var dy = this.startY - otherPolygon.startY;

    var distance = Math.sqrt(dx * dx + dy * dy);

    if (distance < this.radius + otherPolygon.radius) {
      // Collision detected
      return true;
    }

    return false;
  };
}


function drawPolyBullet(PolyGon){
  var isRot
  this.bullet = PolyGon.bullet
  for(let j = 0; j<this.bullet.length;j++){
      var bullet = bul = this.bullet[j]
      if(!bul.image){
      ctx.fillStyle =bul.color
      if(!isRot && this.direction == - 1 || this.direction == 1 || this.direction == - 2 || this.direction == 2 && bul.w > 0){
      ctx.fillRect(bul.x*self.scale,bul.y*self.scale,bul.w*self.scale,bul.h*self.scale)
      }else if(!isRot && this.direction == - 1 || this.direction == 1 || this.direction == - 2 || this.direction == 2 && bul.w < 0){
        ctx.beginPath()
       ctx.arc(this.bullet[j].x*self.scale,this.bullet[j].y*self.scale,this.bullet[j].r*self.scale,0,Math.PI*2)
        ctx.fill()
        ctx.closePath()
      
      }
  
      
      if(bul.w == 0 && bul.h == 0 && !bul.angle){
      ctx.beginPath()
      ctx.arc(this.bullet[j].x*self.scale,this.bullet[j].y*self.scale,this.bullet[j].r*self.scale,0,Math.PI*2)
      ctx.fill()
      ctx.closePath()
      
      }
      
      else if(bul.w == 0 && bul.h == 0 && bul.angle !=0){
      ctx.beginPath()
      ctx.arc(bul.x*self.scale,bul.y*self.scale,bul.r*self.scale,0,Math.PI*2)
      ctx.fill()
      ctx.closePath()
      bul.x+= Math.cos(bul.angle+90*Deg2Rad) * 10
      bul.y+=  Math.sin(bul.angle+90*Deg2Rad) * 10
      isRot = true
      }
      
      else if(bul.w != 0 && bul.h != 0 && bul.angle !=0){
      ctx.save()
      ctx.translate((bul.x+bul.w/2)*self.scale,(bul.y+bul.h/2)*self.scale)
      ctx.rotate(bul.angle)
      ctx.fillRect(-this.bullet[j].w/2*self.scale,-this.bullet[j].h/2*self.scale,this.bullet[j].w*self.scale,this.bullet[j].h*self.scale)
      ctx.restore()
      bul.x+= Math.cos(bul.angle+90*Deg2Rad) *10
      bul.y+=  Math.sin(bul.angle+90*Deg2Rad) *10
      isRot = true
      
      }
      
      }
     
  }


}


function isCollideBoxPolygon(pol, obj) {
  var polygonLeft = pol.startX - pol.radius;
  var polygonRight = pol.startX + pol.radius;
  var polygonTop = pol.startY - pol.radius;
  var polygonBottom = pol.startY + pol.radius;

  if (obj.w == undefined) {
    var dx = pol.startX - obj.x;
    var dy = pol.startY - obj.y;
    var distance = Math.sqrt(dx * dx + dy * dy);

    if (distance <= obj.r + pol.radius / 2 + obj.r) {
      return true
    }

  } else


    var squareLeft = obj.x;
  var squareRight = obj.x + obj.w;
  var squareTop = obj.y;
  var squareBottom = obj.y + obj.h;

  if (polygonRight >= squareLeft &&
    polygonLeft <= squareRight &&
    polygonBottom >= squareTop &&
    polygonTop <= squareBottom) {
    return true;
  }

  return false;


}




// handle sprite without image
Sprite = function (x, y, w, h, vx, vy, color, rotation, id) {
  this.x = x
  this.y = y
  this.w = w
  this.h = h
  this.vx = vx
  this.vy = vy
  this.id = id
  this.rotation = rotation || 0
  this.angle = 0
  this.flipX = false
  this.flipY = false
  this.left = false
  this.hasShadow = false
  this.setGravity = function (x) {
    this.gravity = x
    this.createShadow
  }

  this.color = color

  //handle gravity
  this.setBody = (gv) => {
    this.gv = gv
    if (this.gv == undefined) {
      this.setGravity(35)
      this.vy += this.gravity * 0.016 //0.016
      this.y += Math.floor(this.vy)
    }
    else {
      this.setGravity(this.gv)
      this.vy += this.gravity * 0.016
      this.y += Math.floor(this.vy)
    }

  }

  this.Rotation = function () {
    ctx.translate(this.x * self.scale, this.y * self.scale)
    ctx.rotate(this.angle)
    ctx.translate(-this.x * self.scale, -this.y * self.scale)

  }


  this.createShadow = function (shape) {
    this.shape = shape

    this.hasShadow = true

    shadowY = this.y + this.h + this.r * 4.2

    if (this.collider) {
      this.r = this.collider.w / 1.5
    } else {
      this.r = this.w / 1.5
    }

  }


  // draw sprite with image

  if (!this.color) {
    this.image = new Image()
  }

  this.bullet = []

  this.bullet.image = new Image()


  // draw sprite

  this.drawSprite = function () {
    if (this.hasShadow) {
      ctx.save()
      if (this.shape == "circle") {
        ctx.beginPath()
        ctx.scale(1, 0.5)
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        ctx.arc((this.x + this.w / 2) * self.scale, shadowY * self.scale * 2, this.r * self.scale, 0, Math.PI * 2)
        ctx.fill()
        ctx.closePath()

      }
      if (this.shape == "rect") {
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        if (!this.collider) {
          ctx.fillRect(this.x * self.scale, shadowY * self.scale, this.w * self.scale, this.h * self.scale)
        } else
          ctx.fillRect(this.collider.x * self.scale, shadowY * self.scale, this.collider.w * self.scale, this.collider.h * self.scale)
      }

      ctx.restore()

    }

    if (this.vx > 0) {
      this.left = false
    } else if (this.vx < 0) {
      this.left = true
    }

    var isRot = false
    for (var j = 0; j < this.bullet.length; j++) {
      var bul = this.bullet[j]
      if (!bul.image) {
        ctx.fillStyle = bul.color
        if (!isRot && this.direction == - 1 || this.direction == 1 || this.direction == - 2 || this.direction == 2) {
          ctx.fillRect(bul.x * self.scale, bul.y * self.scale, bul.w * self.scale, bul.h * self.scale)

        }

        if (bul.w == 0 && bul.h == 0 && !bul.angle) {
          ctx.beginPath()
          ctx.arc(this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].r * self.scale, 0, Math.PI * 2)
          ctx.fill()
          ctx.closePath()

        }

        else if (bul.w == 0 && bul.h == 0 && bul.angle != 0) {
          ctx.beginPath()
          ctx.arc(bul.x * self.scale, bul.y * self.scale, bul.r * self.scale, 0, Math.PI * 2)
          ctx.fill()
          ctx.closePath()
          bul.x += Math.cos(bul.angle + 90 * Deg2Rad) * 15
          bul.y += Math.sin(bul.angle + 90 * Deg2Rad) * 15
          isRot = true
        }

        else if (bul.w != 0 && bul.h != 0 && bul.angle != 0) {
          ctx.save()
          ctx.translate((bul.x + bul.w / 2) * self.scale, (bul.y + bul.h / 2) * self.scale)
          ctx.rotate(bul.angle)
          ctx.fillRect(-this.bullet[j].w / 2 * self.scale, -this.bullet[j].h / 2 * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          bul.x += Math.cos(bul.angle + 90 * Deg2Rad) * 15
          bul.y += Math.sin(bul.angle + 90 * Deg2Rad) * 15
          isRot = true

        }


      }

      if (bul.image) {
        if (!isRot) {
          //ctx.drawImage(this.bullet[j].image,this.bullet[j].x*self.scale,this.bullet[j].y*self.scale,this.bullet[j].w*self.scale,this.bullet[j].h*self.scale)
        }

        if (bul.angle) {
          ctx.save()
          ctx.translate((bul.x + bul.w / 2) * self.scale, (bul.y + bul.h / 2) * self.scale)
          ctx.rotate(bul.angle)
          ctx.drawImage(this.bullet[j].image, -(this.bullet[j].w / 2) * self.scale, -(this.bullet[j].h / 2) * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          bul.x += Math.cos(bul.angle + 90 * Deg2Rad) * 15
          bul.y += Math.sin(bul.angle + 90 * Deg2Rad) * 15
          isRot = true

        }

      }

    }

    if (this.flipX && !this.rotation) {
      for (var j = 0; j < this.bullet.length; j++) {
        if (this.bullet[j].image) {
          ctx.save()
          ctx.scale(-1, 1)
          ctx.drawImage(this.bullet[j].image, -this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          return
        } else {
          if (this.bullet[j].w > 0 && this.bullet[j].h > 0) {
            ctx.save()
            ctx.scale(-1, 1)
            ctx.fillStyle = this.bullet[j].color
            ctx.fillRect(-this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
            ctx.restore()
            return
          }

          if (this.bullet[j].w == 0 && this.bullet[j].h == 0) {
            ctx.beginPath()
            ctx.save()
            ctx.scale(-1, 1)
            ctx.arc(-this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].r * self.scale, 0, Math.PI * 2)
            ctx.fill()
            ctx.closePath()
            ctx.restore()
            return

          }

        }


      }


    }




    if (this.rotation && !this.flipX && !rotImage) {

      ctx.save()
      ctx.translate(this.x * self.scale, this.y * self.scale)
      ctx.rotate(this.rotation)  //(Math.sin(this.rotation)*180/Math.PI)
      ctx.fillStyle = this.color
      ctx.fillRect((-this.w / 8) * self.scale, (-this.h / 2) * self.scale, this.w * self.scale, this.h * self.scale)
      ctx.translate(-this.x * self.scale, -this.y * self.scale)
      ctx.restore()
      return
    }


    if (this.rotation && this.flipX && !rotImage) {
      ctx.save()
      this.x = (this.x - this.w / 1.1) * self.scale
      this.y = (this.y - this.h / 2.8) * self.scale
      ctx.translate(this.x * self.scale, this.y * self.scale)
      ctx.scale(-1, 1)
      ctx.rotate(this.rotation)
      ctx.fillStyle = this.color
      ctx.fillRect((-this.w / 8) * self.scale, (-this.h / 2) * self.scale, this.w * self.scale, this.h * self.scale)
      ctx.restore()
      return
    }


    if (this.angle) {

      ctx.save()

      ctx.fillStyle = this.color
      ctx.fillRect(this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)
      ctx.restore()
      return
    }

    

    ctx.fillStyle = this.color
    ctx.fillRect(this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)




    if (this.isVisible) {
      ctx.fillStyle = this.collider.color
      ctx.fillRect(this.collider.x * self.scale, this.collider.y * self.scale, this.collider.w * self.scale, this.collider.h * self.scale)
      if (this.flipX) {
        ctx.save()
        ctx.scale(-1, 1)
        ctx.fillRect(-(this.collider.x + 4.2) * self.scale, this.collider.y * self.scale, -this.w / 2 * self.scale, this.collider.h * self.scale)
        ctx.restore()
      }

    }



  }//Developper : Jean .F CÉRÉLUS


  //single image
  this.drawSpriteImg = function () {
    if (this.hasShadow) {
      ctx.save()
      if (this.shape == "circle") {
        ctx.beginPath()
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        ctx.arc((this.x + this.w / 2) * self.scale, shadowY * self.scale, this.r * self.scale, 0, Math.PI * 2)
        ctx.fill()
        ctx.closePath()

      }
      if (this.shape == "rect") {
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        if (!this.collider) {
          ctx.fillRect(this.x * self.scale, shadowY * self.scale, this.w * self.scale, this.h * self.scale)
        } else
          ctx.fillRect(this.collider.x * self.scale, shadowY * self.scale, this.collider.w * self.scale, this.collider.h * self.scale)
      }

      ctx.restore()

    }


    if (this.vx > 0) {
      this.left = false
    } else if (this.vx < 0) {
      this.left = true
    }


    if (this.isVisible) {
      ctx.fillStyle = this.collider.color
      ctx.fillRect(this.collider.x * self.scale, this.collider.y * self.scale, this.collider.w * self.scale, this.collider.h * self.scale)
      log(6)
      if (this.flipX) {
        ctx.save()
        ctx.scale(-1, 1)
        ctx.fillRect(-(this.collider.x + 4.2) * self.scale, this.collider.y * self.scale, -this.w / 2 * self.scale, this.collider.h * self.scale)
        ctx.restore()
      }

    }


    if (this.flipX && !rotImage) {
      for (var j = 0; j < this.bullet.length; j++) {
        if (imSet) {
          ctx.save()
          ctx.scale(-1, 1)
          ctx.drawImage(this.bullet[j].image, -this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          return

        } else {
          for (var i = 0; i < this.bullet.length; i++) {
            ctx.save()
            ctx.scale(-1, 1)
            ctx.fillStyle = this.bullet[i].color
            ctx.fillRect((-this.bullet[i].x - this.bullet[i].w) * self.scale, this.bullet[i].y * self.scale, this.bullet[i].w * self.scale, this.bullet[i].h * self.scale)
            ctx.globalAlpha = 1
            ctx.restore()
            return
          }
        }

      }

    }

    var isRot = false

    for (var j = 0; j < this.bullet.length; j++) {
      var bul = this.bullet[j]
      if (!bul.image) {
        ctx.fillStyle = this.bullet[j].color
        if (!isRot) {
          ctx.fillRect(this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)

        }


        if (this.bullet[j].w == 0 && this.bullet[j].h == 0 && bul.angle == undefined) {
          ctx.beginPath()
          ctx.arc(this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].r * self.scale, 0, Math.PI * 2)
          ctx.fill()
          ctx.closePath()

        }

        else if (this.bullet[j].w == 0 && this.bullet[j].h == 0 && bul.angle != undefined) {
          ctx.beginPath()
          ctx.arc(this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].r * self.scale, 0, Math.PI * 2)
          ctx.fill()
          ctx.closePath()
          bul.x += Math.cos(bul.angle - 90 * Deg2Rad) * 15
          bul.y += Math.sin(bul.angle - 90 * Deg2Rad) * 15
          isRot = true
        }

        else if (bul.r == 0 && bul.angle != undefined) {
          ctx.save()
          ctx.translate((bul.x + bul.w / 2) * self.scale, (bul.y + bul.h / 2) * self.scale)
          ctx.rotate(bul.angle)
          ctx.fillRect(-this.bullet[j].w / 2 * self.scale, -this.bullet[j].h / 2 * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          bul.x += Math.cos(bul.angle - 90 * Deg2Rad) * 15
          bul.y += -2 + Math.sin(bul.angle - 90 * Deg2Rad) * 15
          isRot = true

        }

      }

      if (bul.image) {
        if (!isRot) {
          ctx.drawImage(this.bullet[j].image, this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
        }

        if (bul.angle != undefined) {
          ctx.save()
          ctx.translate((bul.x + bul.w / 2) * self.scale, (bul.y + bul.h / 2) * self.scale)
          ctx.rotate(bul.angle)
          ctx.drawImage(this.bullet[j].image, -this.bullet[j].w / 2 * self.scale, -this.bullet[j].h / 2 * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          bul.x += Math.cos(bul.angle - 90 * Deg2Rad) * 15
          bul.y += -2 + Math.sin(bul.angle - 90 * Deg2Rad) * 15
          isRot = true

        }

      }


      if (this.bullet[j].image && this.bullet[j].flipX) {
        ctx.save()
        ctx.scale(-1, 1)
        ctx.drawImage(this.bullet[j].image, -this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
        ctx.restore()
        return
      }


      else if (this.bullet[j].image && this.bullet[j].flipY) {
        ctx.save()
        ctx.scale(1, -1)
        ctx.drawImage(this.bullet[j].image, this.bullet[j].x * self.scale, -this.bullet[j].y * self.scale, this.bullet[j].w * self.scale, -this.bullet[j].h * self.scale)
        ctx.restore()
        return
      }

    }



    if (this.angle && this.look == "up" || this.look == "down") {
      ctx.save()
      centerX = (this.x + this.w / 2) * self.scale
      centerY = (this.y + this.h / 2) * self.scale
      ctx.translate(centerX, centerY)
      ctx.rotate(this.angle)
      ctx.drawImage(this.image, -this.w / 2 * self.scale, -this.h / 2 * self.scale, this.w * self.scale, this.h * self.scale)
      ctx.restore()
      return
    }




    if (this.angle && this.look == "left" || this.look == "right") {
      ctx.save()
      centerX = (this.x + this.w / 1.5) * self.scale
      centerY = (this.y + this.h / 1.5) * self.scale
      ctx.translate(centerX, centerY)
      ctx.rotate(this.angle + 90 * Deg2Rad)
      ctx.drawImage(this.image, -this.w / 2 * self.scale, -this.h / 2 * self.scale, this.w * self.scale, this.h * self.scale)
      ctx.restore()
      return
    }


    if (this.flipX && !this.rotation) {
      for (var j = 0; j < this.bullet.length; j++) {
        if (this.bullet[j].image) {
          ctx.drawImage(this.bullet[j].image, -this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.globalAlpha = 1

        } else {
          if (this.bullet[j].w > 0 && this.bullet[j].h > 0) {
            ctx.save()
            ctx.scale(-1, 1)
            ctx.fillStyle = this.bullet[j].color
            ctx.fillRect(-this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
            ctx.restore()
            return
          }

          if (this.bullet[j].w == 0 && this.bullet[j].h == 0) {
            ctx.beginPath()
            ctx.save()
            ctx.scale(-1, 1)
            ctx.arc(-this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].r * self.scale, 0, Math.PI * 2)
            ctx.fill()
            ctx.closePath()
            ctx.restore()
            return
          }

        }


      }


    }



    if (this.flipX && !rotImage) {
      if (rotImage) { return }
      ctx.save()
      ctx.scale(-1, 1)
      ctx.drawImage(this.image, -this.x * self.scale, this.y * self.scale, -this.w * self.scale, this.h * self.scale)
      ctx.globalAlpha = 0
      ctx.restore()
      return
    }


    if (!this.flipX && imSet && !rotImage) {
      if (rotImage) { return }
      ctx.drawImage(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)
    }

    if (this.flipY && !this.rotation && !rotImage && imSet) {
      if (rotImage) { return }
      ctx.save()
      ctx.scale(1, -1)
      ctx.drawImage(this.image, this.x * self.scale, -this.y * self.scale, this.w * self.scale, -this.h * self.scale)
      ctx.globalAlpha = 0
      ctx.restore()
      return
    }
    if (!this.flipY && !this.rotation) {
      if (rotImage) { return }
      ctx.drawImage(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)
    }

    if (this.rotation) { rotImage = true }

    if (this.rotation) { rotImage = true }

    if (this.rotation && this.flipX && rotImage) {

      ctx.save()
      ctx.translate(this.x * self.scale, this.y * self.scale)
      ctx.scale(-1, 1)
      ctx.rotate((this.rotation))
      ctx.drawImage(this.image, -this.w / 8, -this.h / 8, this.w, this.h)
      ctx.restore()

      return
    }





  }

  //Developper : Jean .F CÉRÉLUS


  this.addBullet = function (x, y, w, h, color, r, angle) {
    this.obj = {
      x: x,
      y: y,
      w: w,
      h: h,
      color: color,
      r: r,
      angle: angle,
      direction: this.direction()


    }


    if (this.obj.direction || this.obj.angle) {
      this.bullet.push(this.obj)
    }

  }


  this.addBulletIm = function (x, y, w, h, imSrc, angle) {
    this.obj = {
      x: x,
      y: y,
      w: w,
      h: h,
      flipX: false,
      flipY: false,
      angle: angle,
      direction: this.direction()
    }


    imSet = true
    this.obj.image = new Image()

    this.obj.image.src = imSrc

    if (this.obj.direction || this.obj.angle) {
      this.bullet.push(this.obj)
    }

  }

  // bullet durection direction

  this.direction = function () {


    if (this.vx > 0) {
      return 1
    }

    if (this.vx < 0) {
      return - 1
    }

    if (this.vy > 0) {
      this.vx = 0
      return 2
    }

    if (this.vy < 0) {
      return - 2
    }


  }


  // rotate sprite
  var i = 0;
  this.SpriteRot = function () {
    i += 8

    this.drawSpriteRot(this.x, this.y, this.w, this.h, i);

  }


  this.drawSpriteRot = function (x, y, width, height, angle) {
    ctx.save()
    ctx.translate(x, y);
    ctx.rotate(angle * Deg2Rad);
    ctx.fillStyle = this.color
    ctx.fillRect((-width / 2) * self.scale, (-height / 2) * self.scale, width * self.scale, height * self.scale);
    ctx.restore()

  }



  // rotate spriteImage


  var i = 0;
  this.SpriteImgRot = function () {
    i += 8;
    this.drawSpriteImgRot(this.image, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale, i);
  }


  this.drawSpriteImgRot = function (image, x, y, width, height, angle) {

    ctx.save()
    ctx.translate(x, y);
    ctx.rotate(angle * Deg2Rad);
    ctx.drawImage(this.image, (-width / 2) * self.scale, (-height / 2) * self.scale, width * self.scale, height * self.scale);
    ctx.restore()
    return this

  }

}


// circle method

Circle = function (x, y, r, vx, vy, color, id) {
  this.x = x
  this.y = y
  this.r = r
  this.vx = vx
  this.vy = vy
  this.id = id
  this.left = false
  this.setGravity = function (x) {
    this.gravity = x
    this.isDrawn = false
    this.hasShadow = false
  }



  this.color = color

  this.bullet = []

  this.bullet.image = new Image()


  this.createShadow = function (shape) {
    this.shape = shape

    this.hasShadow = true

    shadowY = this.y + this.h + this.r * 4.2

    if (this.collider) {
      this.r = this.collider.w / 1.5
    } else {
      this.r = this.w / 1.5
    }

  }


  //handle gravity
  this.setBody = (gv) => {
    this.gv = gv
    if (this.gv == undefined) {
      this.setGravity(35)
      this.vy += this.gravity * 0.016 //0.016
      this.y += Math.floor(this.vy)
    }
    else {
      this.setGravity(this.gv)
      this.vy += this.gravity * 0.016
      this.y += Math.floor(this.vy)
    }

  }

  // draw circle

  this.drawCirc = function () {

    if (this.hasShadow) {
      ctx.save()
      if (this.shape == "circle") {
        ctx.beginPath()
        ctx.scale(1, 0.5)
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        ctx.arc((this.x + this.w / 2) * self.scale, shadowY * self.scale * 2, this.r * self.scale, 0, Math.PI * 2)
        ctx.fill()
        ctx.closePath()

      }
      if (this.shape == "rect") {
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        if (!this.collider) {
          ctx.fillRect(this.x * self.scale, shadowY * self.scale, this.w * self.scale, this.h * self.scale)
        } else
          ctx.fillRect(this.collider.x * self.scale, shadowY * self.scale, this.collider.w * self.scale, this.collider.h * self.scale)
      }

      ctx.restore()

    }

    if (this.vx > 0) {
      this.left = false
    } else if (this.vx < 0) {
      this.left = true
    }

    ctx.beginPath()
    ctx.fillStyle = this.color
    ctx.arc(this.x * self.scale, this.y * self.scale, this.r * self.scale, 0, Math.PI * 2)
    ctx.fill()
    ctx.closePath()

    this.isDrawn = true


    for (b of this.bullet) {
      ctx.fillStyle = b.color
      if (b.w > 0 && b.h > 0) {
        ctx.fillStyle =
          ctx.fillRect(b.x * self.scale, b.y * self.scale, b.w * self.scale, b.h * self.scale)
      }

      if (b.w == 0 && b.h == 0) {
        ctx.beginPath()
        ctx.arc(b.x * self.scale, b.y * self.scale, b.r * self.scale, 0, Math.PI * 2)
        ctx.fill()
        ctx.closePath()
      }


    }


  }


  this.addBullet = function (x, y, w, h, color, r) {
    this.obj = {
      x: x,
      y: y,
      w: w,
      h: h,
      color: color,
      r: r,
      direction: this.direction()

    }

    if (this.obj.direction || this.obj.angle) {
      this.bullet.push(this.obj)
    }

  }



  this.addBulletIm = function (x, y, w, h, imSrc) {
    this.obj = {
      x: x,
      y: y,
      w: w,
      h: h,
      flipX: false,
      flipY: false,
      direction: this.direction()

    }


    imSet = true
    this.obj.image = new Image()
    this.obj.image.src = imSrc

    if (this.obj.direction || this.obj.angle) {
      this.bullet.push(this.obj)
    }

  }

}

// bullet durection direction

this.direction = function () {

  if (this.vx < 0) {
    return - 1
  }

  else if (this.vx > 0) {
    return 1
  }

  else if (this.vy < 0) {
    return - 2
  }

  else if (this.vy > 0) {
    return 2
  }




}


// spriteSheet
SpriteSheet = function (col, row, sw, sh, x, y, w, h, vx, vy, id) {
  this.row = row
  this.col = col
  this.sw = sw
  this.sh = sh

  this.x = x
  this.y = y
  this.w = w
  this.h = h
  this.vx = vx
  this.vy = vy
  this.id = id
  this.angle = 0
  this.flipX = false
  this.flipY = false
  this.left = false
  this.hasShadow = false
  this.setGravity = function (x) {
    this.gravity = x
  }


  this.createShadow = function (shape) {
    this.shape = shape

    this.hasShadow = true

    shadowY = this.y + this.h + this.r * 4.2

    if (this.collider) {
      this.r = this.collider.w / 1.5
    } else {
      this.r = this.w / 1.5
    }

  }



  //handle gravity
  this.setBody = (gv) => {
    this.gv = gv
    if (this.gv == undefined) {
      this.setGravity(35)
      this.vy += this.gravity * 0.016
      this.y += Math.floor(this.vy)
    }
    else {
      this.setGravity(this.gv)
      this.vy += this.gravity * 0.016
      this.y += Math.floor(this.vy)

    }

  }

  this.isVisible = false

  imSet = true
  this.image = new Image()
  this.bullet = []

  this.bullet.image = new Image()


  //spritesheet image
  this.drawSpriteSheet = function () {
    if (this.hasShadow) {
      ctx.save()
      if (this.shape == "circle") {
        ctx.beginPath()
        ctx.scale(1, 0.5)
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        if(this.flipX){
          ctx.arc(((this.x) + this.w / 2) * self.scale, shadowY * self.scale * 2, this.r * self.scale, 0, Math.PI * 2)
           ctx.fill()

       }else{
        ctx.arc((this.x + this.w / 2) * self.scale, shadowY * self.scale * 2, this.r * self.scale, 0, Math.PI * 2)
        ctx.fill()
        ctx.closePath()
        }
      }
      if (this.shape == "rect") {
        ctx.fillStyle = "rgba(0,0,0,0.5)"
        if (!this.collider) {
          ctx.fillRect(this.x * self.scale, shadowY * self.scale, this.w * self.scale, this.h * self.scale)
        } else
           if(this.flipX){
              ctx.fillRect((this.collider.x) * self.scale, (shadowY+5) * self.scale, this.collider.w * self.scale, this.collider.h/2 * self.scale)        
           }else
             ctx.fillRect(this.collider.x * self.scale, (shadowY+5) * self.scale, this.collider.w * self.scale, this.collider.h/2 * self.scale)
      }

      ctx.restore()

    }


    if (this.vx > 0) {
      this.left = false
    } else if (this.vx < 0) {
      this.left = true
    }


    if (!this.flipX && !this.rotation && !this.angle) {
      ctx.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, this.x * self.scale, this.y * self.scale, this.w * self.scale, this.h * self.scale)
    }



    if (this.angle && this.look == "up" || this.look == "down") {
      ctx.save()
      centerX = (this.x + this.w / 1.5) * self.scale
      centerY = (this.y + this.h / 1.5) * self.scale
      ctx.translate(centerX, centerY)
      ctx.rotate(this.angle + 90 * Deg2Rad)
      ctx.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, -this.w / 1.5 * self.scale, -this.h / 1.5 * self.scale, this.w * self.scale, this.h * self.scale)
      ctx.restore()

    }


    if (this.angle && this.look == "left" || this.look == "right") {
      ctx.save()
      centerX = (this.x + this.w / 1.5) * self.scale
      centerY = (this.y + this.h / 1.5) * self.scale
      ctx.translate(centerX, centerY)
      ctx.rotate(this.angle + 90 * Deg2Rad)
      ctx.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, -this.w / 1.5 * self.scale, -this.h / 1.5 * self.scale, this.w * self.scale, this.h * self.scale)
      ctx.restore()

    }

    var isRot = false
    for (var j = 0; j < this.bullet.length; j++) {
      var bul = this.bullet[j]
      if (!bul.image) {
        if (!isRot) {
          ctx.fillStyle = this.bullet[j].color
          ctx.fillRect(this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
        }



        if (this.bullet[j].w == 0 && this.bullet[j].h == 0 && this.bullet[j].angle == undefined) {
          ctx.beginPath()
          ctx.arc(this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].r * self.scale, 0, Math.PI * 2)
          ctx.fill()
          ctx.closePath()

        }

        else if (this.bullet[j].w == 0 && this.bullet[j].h == 0 && bul.angle != undefined) {
          ctx.beginPath()
          ctx.arc(this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].r * self.scale, 0, Math.PI * 2)
          ctx.fill()
          ctx.closePath()
          bul.x += Math.cos(bul.angle - 90 * Deg2Rad) * 15
          bul.y += Math.sin(bul.angle - 90 * Deg2Rad) * 15

        }

        else if (bul.r == 0 && bul.angle != undefined) {

          ctx.save()
          ctx.translate((bul.x + bul.w / 1.5) * self.scale, (bul.y + bul.h / 2) * self.scale)
          ctx.rotate(bul.angle)
          ctx.fillRect(-this.bullet[j].w / 1.5 * self.scale, -this.bullet[j].h / 2 * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          bul.x += Math.cos(bul.angle - 90 * Deg2Rad) * 10
          bul.y += -2 + Math.sin(bul.angle - 90 * Deg2Rad) * 10
          isRot = true

        }



      }

      if (bul.image) {
        if (!isRot) {
          ctx.drawImage(this.bullet[j].image, this.bullet[j].x * self.scale, this.bullet[j].y * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
        }

        if (bul.angle != undefined) {
          ctx.save()
          ctx.translate((bul.x + bul.w / 2) * self.scale, (bul.y + bul.h / 2) * self.scale)
          ctx.rotate(bul.angle)
          ctx.drawImage(this.bullet[j].image, -this.bullet[j].w / 2 * self.scale, -this.bullet[j].h / 2 * self.scale, this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
          ctx.restore()
          bul.x += Math.cos(bul.angle - 90 * Deg2Rad) * 15
          bul.y += -2 + Math.sin(bul.angle - 90 * Deg2Rad) * 15
          isRot = true

        }

      }



      if (this.bullet[j].image && this.bullet[j].flipX ) {
        ctx.save()
        ctx.scale(-1, 1)
        ctx.globalAlpha = 1
        ctx.drawImage(this.bullet[j].image, -(this.bullet[j].x-5) * self.scale, this.bullet[j].y * self.scale, -this.bullet[j].w * self.scale, this.bullet[j].h * self.scale)
        ctx.restore()
        ctx.globalAlpha = 0
      }

      if (this.bullet[j].image && this.bullet[j].flipY) {
        ctx.save()
        ctx.scale(1, -1)
        ctx.drawImage(this.bullet[j].image, this.bullet[j].x * self.scale, -this.bullet[j].y * self.scale, this.bullet[j].w * self.scale, -this.bullet[j].h * self.scale)
        ctx.restore()
        return
      }


    }





    if (this.flipY) {
      ctx.save()
      ctx.scale(1, -1)
      ctx.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, this.x * self.scale, -this.y * self.scale, this.w * self.scale, -this.h * self.scale)
      ctx.restore()

      return
    }

    if (this.flipX) {
      ctx.save()
      ctx.scale(-1, 1)
      ctx.globalAlpha = 1
      ctx.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw,
        this.sh, (-this.x - this.w /1.3) * self.scale, this.y * self.scale,
        this.w * self.scale, this.h * self.scale)
      ctx.restore()

    }



    if (this.isVisible) {
      ctx.fillStyle = this.collider.color
      if (!this.flipX) {
        ctx.fillRect(this.collider.x * self.scale, this.collider.y * self.scale,
          this.collider.w * self.scale, this.collider.h * self.scale)
      }

      if (this.flipX) {
        ctx.save()
        ctx.scale(-1, 1)
        if (this.w <= 99)
          ctx.fillRect(-(this.collider.x + this.collider.w / 3.2) * self.scale, this.collider.y * self.scale,
            -this.collider.w * self.scale, this.collider.h * self.scale)
        if (this.w >= 100)
          ctx.fillRect(-(this.collider.x + this.collider.w / 3.2) * self.scale, this.collider.y * self.scale, -this.w / 8 * self.scale, this.collider.h * self.scale)

        ctx.restore()
      }

    }


  }


  this.addBullet = function (x, y, w, h, color, r, angle) {
    this.obj = {
      x: x,
      y: y,
      w: w,
      h: h,
      color: color,
      r: r,
      angle: angle,
      direction: this.direction()

    }

    this.bullet.push(this.obj)

  }



  this.addBulletIm = function (x, y, w, h, imSrc, angle) {
    this.obj = {
      x: x,
      y: y,
      w: w,
      h: h,
      flipX: false,
      flipY: false,
      angle: angle,
      direction: this.direction()

    }


    var imSet = true
    this.obj.image = new Image()
    this.obj.image.src = imSrc

    this.bullet.push(this.obj)


  }


  // bullet durection direction

  this.direction = function () {

    if (this.vx > 0) {

      return 1
    }

    if (this.vx < 0) {
      return - 1
    }

    if (this.vy > 0) {

      return 2
    }

    if (this.vy < 0) {
      return - 2
    }

  }


  // rotate spriteSheet


  var i = 0;
  this.SpriteSheetRot = function () {
    i += 8;
    this.drawSpriteSheetRot(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, this.x, this.y, this.w, this.h, i);

  }


  this.drawSpriteSheetRot = function (image, col, row, w, h, x, y, width, height, angle) {
    ctx.save()
    ctx.translate(x * self.scale, y * self.scale);
    ctx.rotate(angle * Deg2Rad);
    ctx.drawImage(this.image, this.col * this.sw, this.row * this.sh, this.sw, this.sh, -(width / 2) * self.scale, -(height / 2) * self.scale, width * self.scale, height * self.scale);
    ctx.restore()

  }






}



//all possible simple collisions detection


//this is for cirlcle and square or rect collision
function isOverlap(b, a) {
  var dx = Math.abs(a.x - (b.x + b.w / 2));
  var dy = Math.abs(a.y - (b.y + b.h / 2));
  if (dx <= a.r + a.r + b.w / 2 && dy <= a.r + a.r + b.h / 2) {
    return true

  }




}



//this is for AABB Collision
function isCollide(a, b) {

  if (a.x + a.w >= b.x &&
    a.x <= b.x + b.w &&
    a.y + a.h >= b.y &&
    a.y <= b.y + b.h ||
    a.x + a.w >= b.x &&
    a.x <= b.x + b.width &&
    a.y + a.h >= b.y &&
    a.y <= b.y + b.height ||

    a.x + a.w >= b.x &&
    a.x <= b.x + b.w &&
    a.y + a.h + a.vy >= b.y &&
    a.y <= b.y + b.h

  ) {

    return true
  }





}




//this is for Circle vs  circle Collision
function isInterCirc(a, b) {
  dx = a.x - b.x
  dy = a.y - b.y

  sumr = a.r + b.r
  distance = Math.sqrt(dx * dx + dy * dy)

  if (distance <= sumr) {
    return true
  }

}




/* tilemap without using tiled editor
or else */

var isDrawable = true
function tileMap(lev, colTCount, rowTCount, total, ts, s, Src, w, h) {
  this.image = new Image()
  this.image.src = Src
  this.lev = lev
  this.colTCount = colTCount
  this.rowTCount = lev.length
  this.total = total
  this.ts = ts
  this.s = s
  this.w = w
  this.h = h
  this.image.onload = this.drawLayer

  this.drawLayer = function () {
    for (var r = 0; r < this.rowTCount; r++) {
      for (var col = 0; col < this.colTCount; col++) {
        var tile = this.lev[r][col]
        var tileRow = (tile / total) | 0
        var tileCol = (tile % total) | 0

        if (tileCol + ts / 2 < camera.x - ts / 2 || tileCol + ts > camera.x + camera.width + ts / 2) { isDrawable = false } else { isDrawable = true }
        if (isDrawable)

          if (this.w == undefined && this.h == undefined) {
            ctx.drawImage(this.image, (tileCol * ts), (tileRow * ts), ts, ts, (col * s) * self.scale, (r * s) * self.scale, s * self.scale, s * self.scale)

          }

        if (this.w && this.h) {
          ctx.drawImage(this.image, (tileCol * ts), (tileRow * ts), ts, ts, (col * s) * self.scale, (r * s) * self.scale, this.w * self.scale, this.h * self.scale)
        }

      }

    }


  }


  return this

}









/*Jcerelus Dev All Rights Reserved
Developper : Jean .F CÉRÉLUS
canvasJs is a javascript canvas library, 
that makes you develop game very  quick
all of the work is done behind the scene.
Developper : Jean .F CÉRÉLUS
*/

var goLeft = false
var goRight = false

function isFollow(a, b) {
  gap = a.x - b.x
  var diffY = Math.abs(a.y - b.y)

  if (gap <= 15 && gap >= - 15) {
    return
  }

  if (gap <= -20 && gap >= -140 && diffY <= 20) {
    goLeft = true
    goRight = false
    return true
  }

  if (gap >= 0 && gap <= 140 && diffY <= 20) {
    goLeft = false
    goRight = true
    return true
  }
  return gap
}


/*create a grid whenever you want to
draw tilemap from a tilset by hand
*/

function createGrid(gap, gW, gH, color) {
  this.gap = gap
  this.w = gW
  this.w = gH
  this.color = color

  this.drawGrid = function () {
    for (var x = this.gap; x < this.w; x += this.gap) {
      if (this.w >= this.h) {
        ctx.moveTo(x, 0)
        ctx.lineTo(x, this.w)

      }
      else {
        ctx.moveTo(x, 0)
        ctx.lineTo(x, this.h)

      }

    }

    for (var y = this.gap; y < this.gH; y += this.gap) {
      ctx.moveTo(0, y)
      ctx.lineTo(this.gW, y)

    }

    ctx.strokeStyle = this.color
    ctx.lineWidth = 1
    ctx.stroke()

  }

}


function addNumber(col, row, tSize, color, spaceX, spaceY) {
  this.col = col;
  this.row = row
  this.tSize = tSize
  this.color = color
  this.spaceX = spaceX
  this.spaceY = spaceY

  this.show = () => {
    for (var r = 0; r <= this.row; r++) {
      for (var cl = 0; cl <= this.col; cl++) {

        var count = cl + r * this.col

        ctx.font = "9px arial bold"
        ctx.fillStyle = this.color
        ctx.fillText(count, cl * this.tSize + this.spaceX, r * this.tSize + this.spaceY)

      }

    }
  }

  return this
}

//tileMap with tiled Editor
var row
var column
let loader = false
let that
var data

var isLayer = false
var isObject = false

function tiledMap(path, image, size) {

  that = this
  that.path = path
  that.image = image = new Image()

  that.size = size


  that.load = function () {
    xhr = new XMLHttpRequest()
    xhr.onload = function () {
      if (this.readyState == 4) {

        data = JSON.parse(xhr.response)
        loader = true
        that.loadTileset(data)

      }

    }

    xhr.open("get", that.path)
    xhr.send(true)

  }



  that.loadTileset = function (json) {
    var pattern = /..\/+/
    for (tile of data.tilesets) {
      that.image.src = tile.image.replace(pattern, "")

    }

  }


  animL = []
  var animLayer = false
  that.renderLayer = function (layer) {

    for (r = 0; r < layer.height; r++) {
      for (col = 0; col < layer.width; col++) {
        let index = (col + r * layer.width)
        let tid = layer.data[index]

        tid--

        tX = (tid % (tile.imagewidth / size)) * size;
        tY = ~~(tid / (tile.imagewidth / size)) * size;
        dX = (index % layer.width) * size
        dY = ~~(index / layer.width) * size

        //canvas 2
        if ((dX + size) < (camera.x) || (dX + size) > (camera.x + camera.width) + 100) { isDrawable = false } else { isDrawable = true }
        if (isDrawable)
         ctx.globalAlpha = 1
          ctx.drawImage(that.image, tX, tY, size, size, dX * self.scale, dY * self.scale, size * self.scale, size * self.scale)


        if (tile.tiles) {
          tile.tiles.forEach((tL, i) => {
            animL.push(tL)

            if (tid != 0 && animL[tid] != undefined || animL[tid] != null) {
              animLayer = true
              var anim = animL[tid].animation
              numFrames = anim.length
              tIndex = layerframe % numFrames
              if (animLayer && tid == tL.id) {

                tid = anim[tIndex].tileid + 1

                tX = (tid % (tile.imagewidth / size)) * size;
                tY = Math.floor(tid / (tile.imagewidth / size)) * size;
                dX = (index % layer.width) * size
                dY = Math.floor(index / layer.width) * size

                //canvas 3
                if ((dX + size) < (camera.x) || (dX + size / 2) > (camera.x + camera.width) + 100) { isDrawable = false } else { isDrawable = true }

                if (isDrawable)
                  isLayer = true
                  ctx.globalAlpha = 1
                ctx.drawImage(that.image, tX, tY, size, size, dX * self.scale, dY * self.scale, size * self.scale, size * self.scale)
              }


            }

          })
        }




      }
    }


    //Gestion d'animation
    //canvas 6
    var canAnimate = false
    self.objectAnimation = tileAnimation = function (gidValue, nom) {
      that.val = gidValue
      this.nom = nom


      for (layer of data.layers) {
        if (layer.type == "objectgroup" && this.nom == layer.name) {
          if (tile.tiles) {
            isObject = true
            for (let t of tile.tiles) {
              anim = t.animation

              var numberFrames = anim.length
              frameIndex = objframe % numberFrames
              var value


              value = anim[frameIndex].tileid


              tileColumns = tile.imagewidth / tile.tilewidth
              tileRows = tile.imageheight / tile.tileheight
              var sw = tile.tileheight
              var sh = tile.tilewidth


              for (var effect of layer.objects) {
                if (effect.hasOwnProperty("gid") && effect.gid == that.val && this.nom == layer.name) {
                  canAnimate = true

                }

                else {
                  canAnimate = false
                  log(" Animation Layer's name is not defined or gidValue is incorrect in tileAnimation \n\n please read the documentation so that you may use tileAnimation correctly !!")
                }




                // To find the specific object image  in each colunm: object gid % tilecolumn * sw & divide it  by 2 then multiply it by 0.1 and math.round it
                //for the row : object gid & multiply it by sh,  then divide it by 1000 & multiply it by tile.columns and  math.floor it.
                //check for different tsize
                column = Math.floor((value % tile.columns))
                objrow = Math.floor(value / tile.columns)


                if (effect.x + sw < camera.x || effect.x + sw / 2 > camera.x + camera.width) { isDrawable = false } else { isDrawable = true }
                if (!isDrawable) {
                  canAnimate = false
                }

                if (canAnimate) {
                 ctx.globalAlpha = 1
                  ctx.drawImage(that.image, sw * column, sh * objrow, sw, sh,
                    effect.x * self.scale, (effect.y - sh) * self.scale, effect.width * self.scale, effect.height * self.scale)
                }

              }

            }

          }

        }


      }

    }

  }

  //render object layers
  //canvas 4
  that.RenderObjectLayer = function (Gid) {
    this.gid = Gid
    gid = this.gid

    for (var layer of data.layers) {

      if (layer.type == "objectgroup") {
        tile.rows = tile.imageheight / tile.tileheight
        layer.objects.forEach(function (obl) {
          if (obl.hasOwnProperty("gid") && obl.gid == gid) {
            if (obl.gid != gid) { obl.gid = gid }

            var sw = tile.imagewidth / tile.columns
            var sh = tile.imageheight / tile.rows


            // it's important for different tile size
            column = Math.floor(((gid - 1) % tile.columns))
            obj2row = Math.floor(gid / tile.columns)


            //if(dX*self.scale < camera.x*self.scale || dX*self.scale > (camera.x*self.scale+camera.width*self.scale) + 100 ){isDrawable = false}else{isDrawable = true;log(isDrawable)}
            if ((obl.x + sw) < (camera.x) || (obl.x + sw / 2) * self.scale > (camera.x + camera.width) * self.scale + 100) { isDrawable = false } else { isDrawable = true }
            if (obl.hasOwnProperty("gid") && obl.gid != that.val && !layer.hasOwnProperty("properties") && isDrawable) {
             ctx.globalAlpha = 1
              ctx.drawImage(that.image, sw * column, sh * obj2row, sw, sh
                , obl.x * self.scale, (obl.y - obl.height) * self.scale, obl.width * self.scale, obl.height * self.scale)
            }


          }

          else if (obl.hasOwnProperty("gid") && obl.type == "auto") {
            gid = obl.gid
            var sw = tile.imagewidth / tile.columns
            var sh = tile.imageheight / tile.rows


            // it's important for different tile size
            column = Math.floor(((gid - 1) % tile.columns))
            obj2row = Math.floor(gid / tile.columns)

            //if(dX*self.scale < camera.x*self.scale || dX*self.scale > (camera.x*self.scale+camera.width*self.scale) + 100 ){isDrawable = false}else{isDrawable = true;log(isDrawable)}
            if ((obl.x + sw) < (camera.x) || (obl.x + sw / 2) * self.scale > (camera.x + camera.width) * self.scale + 100) { isDrawable = false } else { isDrawable = true }
            if (obl.hasOwnProperty("gid") && obl.gid != that.val && !layer.hasOwnProperty("properties") && isDrawable) {
               ctx.globalAlpha = 1
              ctx.drawImage(that.image, sw * column, sh * obj2row, sw, sh
                , obl.x * self.scale, (obl.y - obl.height) * self.scale, obl.width * self.scale, obl.height * self.scale)
            }

          }
          //endof auto render


        })

      }

    }
  }



  return that
}



function canDraw(a, b) {
  if ((a.x + a.w) < (b.x) || (a.x + a.w) > (b.x + b.width) || (a.x + a.r) < b.x || (a.x + a.r) > (b.x + b.width)) {
    return false
  } else {
    return true
  }

}


function tiledCollider(a, b) {
  var dist = Math.abs(a.y - a.h - b.y + b.height)
  if (!b.gid && a.x + a.w >= b.x &&
    a.x <= b.x + b.width &&
    a.y + a.h >= b.y &&
    a.y <= b.y + b.height ||
    a.x + a.w >= b.x &&
    a.x <= b.x + b.w &&
    a.y + a.h >= b.y &&
    a.y <= b.y + b.h

  ) {
    return true
  }



  else if (b.gid && a.x + a.w >= b.x &&
    a.x <= b.x + b.width &&
    a.y + a.h >= b.y &&
    a.y <= b.y + b.height && dist <= 20) {
    return true

  }


}



var isX = false

//Vertical rpg Collider
function VrpgCollider(lname, obj) {
  if (loader)
    obj.onFloor = true
  data.layers.forEach(function (layer) {

    if (layer.type == "objectgroup") {
      if (layer.name == lname)

        layer.objects.forEach(function (ob) {
          const body = obj.collider


          if (!obj.collider) {
            if (obj.x + obj.w >= ob.x && obj.x <= ob.x + ob.width &&
              obj.y + obj.h >= ob.y && obj.y <= ob.y + ob.height) {
              obj.x = obj.oldX;
              obj.y = obj.oldY;

            }

          } else {
            if (isCollide(body, ob)) {

              if (obj.vy < 0 && body.y > ob.y) {
                obj.vy = 0

                if (obj.vy == 0) {
                  if (obj.shape == "circle")
                    shadowY = shadowY - 27
                  if (obj.shape == "rect")
                    shadowY = shadowY - 33
                }

                const offset = body.y - obj.y;
                obj.y = ob.y + ob.height - offset + 0.01
                body.y = ob.y + ob.height - offset + 0.01
                return

              }


              if (obj.vy > 0 && body.y < ob.y) {

                obj.vy = 0

                const offset = body.y - obj.y + body.h;
                obj.y = ob.y - ob.height - 0.01
                //body.y = ob.y - body.h - 0.01
                return
              }


            }


          }

        })

    }

  })

  return
}


//horizontal rpg collider

function HrpgCollider(lname, obj) {
  if (loader)
    obj.onFloor = true
  if (obj.vx != 0) {
    isX = true
  } else {
    isX = false
  }

  if (isX) { obj.vy = 0 }

  if (!obj.vy == 0) return

  data.layers.forEach(function (layer) {

    if (layer.type == "objectgroup") {
      if (layer.name == lname)

        layer.objects.forEach(function (ob) {
          const body = obj.collider


          if (!obj.collider) {
            if (obj.x + obj.w >= ob.x && obj.x <= ob.x + ob.width &&
              obj.y + obj.h >= ob.y && obj.y <= ob.y + ob.height) {
              obj.x = obj.oldX;
              obj.y = obj.oldY;

            }

          } else {

            if (isCollide(body, ob)) {
              if (obj.vx > 0) {

                obj.vy = 0
                const offset = body.x - obj.x + body.w;
                obj.x = ob.x - offset - 0.01;
                return true
              }



              else if (obj.vx < 0) {
                obj.onFloor = true
                obj.vy = 0
                const offset = body.x - obj.x
                obj.x = ob.x + ob.width - offset + 0.01

                return true;
              }


            }


          }

        })

    }

  })


}



// any tile collision

var canJump = false


//rpg follow
var Lside = false, Rside = false, Uside = false, Dside = false;

function RpgFollow(a, b, gap) {
  this.gap = gap
  var angle = Math.atan2(a.y - b.y, a.x - b.x)
  var dx = (a.x - b.x)
  var dy = (a.y - b.y)

  var dist = self.getDistance(a, b)
  if (gap <= 10 && gap >= -10) return
  if (dist <= this.gap) {

    b.vx = Math.cos(angle)
    b.vy = Math.sin(angle)
    b.x += b.vx
    b.y += b.vy

    let diffX = (a.x - b.x)
    let diffY = (a.y - b.y)

    if (a.vx < 0 && diffY <= 10 && diffX != 0) {
      Rside = false;
      Uside = false;
      Dside = false;
      return Lside = true;
    } else if (a.vx > 0 && diffY <= 10 && diffX != 0) {
      Lside = false;
      Uside = false;
      Dside = false;
      return Rside = true;
    } else if (a.vy < 0) {
      Rside = false
      Dside = false
      Lside = false
      return Uside = true;
    } else if (a.vy > 0) {
      Rside = false;
      Uside = false;
      Lside = false;
      return Dside = true;
    }

  }
  return false

}




function gameRadar(x, y) {
  this.x = x
  this.y = y
  var cvIm = new Image()
  cvIm.src = this.x.toDataURL()
  this.y.style.background = `url(${cvIm.src})`
  this.y.style.backgroundRepeat = "no-repat"
  this.y.style.backgroundSize = "cover"

}

/*Fake 3d effect*/

var gameFrame = 0
var gameSpeed = 5

class layerB {
  constructor(image, x, y, w, h, speedModifier) {
    if (w != gW) w = gW

    this.x = x
    this.y = y
    this.image = image
    this.w = w
    this.h = h
    this.speedModifier = speedModifier
    this.speed = gameSpeed * this.speedModifier

  }

  update() {
    this.speed = gameSpeed * this.speedModifier
    this.x = gameFrame * this.speed % this.w
    isFake = true
  }

  draw() {
    isFake = true
    ctx.save()
    if (gameFrame == 0) {
      ctx.drawImage(this.image, this.x, this.y, this.w, this.h)
    }
    if (gameFrame < 0) {
      ctx.drawImage(this.image, this.x, this.y, this.w, this.h)
      ctx.drawImage(this.image, this.x + this.w, this.y, this.w, this.h)
    } else if (gameFrame > 0) {
      ctx.drawImage(this.image, this.x, this.y, this.w, this.h)
      ctx.drawImage(this.image, this.x - this.w, this.y, this.w, this.h)
    }
    ctx.restore()

  }

}

console.dir("CanvasgGameJs is running !!")



// side platformer collider
var isJumping = false

function LeftCollider(grid, obj, ts, tindex) {
  for (var r = 0; r < grid.length; r++) {
    for (var c = 0; c < grid[0].length; c++) {

      if (grid[r][c] == tindex) {
        var tx = c * ts
        var ty = r * ts
        block = new Sprite(tx, ty, ts, ts, 0, 0, "red")



        if (obj.collider) {
          const body = obj.collider

          if (obj.vx > 0 && body.x + body.w >= block.x && body.x <= block.x + block.w &&
            body.y + body.h >= block.y && body.y <= block.y + block.h && body.y > block.y) {
            const offset = body.x - obj.x + body.w

            obj.x = block.x - offset - 0.01

            break;

          }

        } else {

          if (obj.vx > 0 && obj.x + obj.w >= block.x && obj.x <= block.x + block.w &&
            obj.y + obj.h >= block.y && obj.y <= block.y + block.h) {


            obj.x = block.x - obj.w - 1  //obj.oldX + 0.01
          }

        }

      }

    }

  }

}





function RightCollider(grid, obj, ts, tindex) {


  for (var r = 0; r < grid.length; r++) {
    for (var c = 0; c < grid[0].length; c++) {


      if (grid[r][c] == tindex) {
        var tx = c * ts
        var ty = r * ts
        block = new Sprite(tx, ty, ts, ts, 0, 0, "red")


        if (obj.collider) {

          const body = obj.collider
          if (obj.vx < 0 && body.x + body.w >= block.x && body.x <= block.x + block.w &&
            body.y + body.h >= block.y && body.y <= block.y + block.h && body.y > block.y) {
            const offset = body.y - obj.y
            obj.x = obj.oldX + 0.01
            //obj.x = block.x + block.w +1 //- offset + 0.01
            break;
          }

        }
        else {


          if (obj.vx < 0 && obj.x + obj.w >= block.x && obj.x <= block.x + block.w &&
            obj.y + obj.h >= block.y && obj.y <= block.y + block.h) {
            obj.x = block.x + block.w + 1
            break;
          }

        }

      }
    }
  }

}





function TopCollider(grid, obj, ts, tindex) {

  for (var r = 0; r < grid.length; r++) {
    for (var c = 0; c < grid[0].length; c++) {
      var tx = c * ts
      var ty = r * ts
      var blocks = []
      if (grid[r][c] == tindex) {

        blocks.push(new Sprite(tx, ty, ts, ts, 0, 0, "red"))

        for (var b = 0; b < blocks.length; b++)
          var block = blocks[b]

        if (obj.collider) {

          const body = obj.collider

          if (obj.vy > 0 && body.x + body.w > block.x && body.y + body.h + obj.vy > block.y &&
            body.x < block.x + block.w && body.y + obj.vy < block.y + block.h && obj.y < block.y) {
            const offset = body.y - obj.y + body.h
            obj.vy = 0
            obj.onFloor = true
            obj.y = block.y - obj.h - 0.01
            obj.collider.y = block.y - obj.collider.h - 0.01 //ob.y - obj.h - 0.01
            JumpTime = 0
            break;
          }

        } else {

          if (obj.vy > 0 && obj.x + obj.w > block.x && obj.y + obj.h + obj.vy > block.y &&
            obj.x < block.x + block.w && obj.y + obj.vy < block.y + block.h && obj.y < block.y) {

            obj.vy = 0

            if (obj.vy == 0) {
              if (obj.shape == "circle")
                shadowY = shadowY - 27
              if (obj.shape == "rect")
                shadowY = shadowY - 33
            }

            obj.y = block.y - obj.h - 0.01

            JumpTime = 0
            obj.onFloor = true
            break;

          }


        }



      }

    }
  }

}


function BottomCollider(grid, obj, ts, tindex) {


  for (var r = 0; r < grid.length; r++) {
    for (var c = 0; c < grid[0].length; c++) {
      var block

      if (grid[r][c] == tindex) {
        tx = c * ts
        ty = r * ts
        block = { x: tx, y: ty, w: ts, h: ts }

        if (obj.collider) {
          const body = obj.collider

          if (isJumping && obj.vy < 0 && (body.x - obj.vx) + body.w > block.x - obj.vx && body.y + body.h >= block.y &&
            body.x - obj.vx <= block.x + block.w - obj.vx && body.y <= block.y + block.h) {

            const offset = body.y - obj.y

            obj.y = (block.y + block.h - 5) - offset + 9
            obj.collider.y = block.y + block.h - offset + 9

  
            isJumping = false
            obj.vy = 0
            break;
          }

        } else {

          if (isJumping && obj.x + obj.w > block.x && obj.y + obj.h >= block.y &&
            obj.x <= block.x + block.w && obj.y <= block.y + block.h) {

            obj.y = block.y + block.h + 0.01

            obj.vy = 0
            isJumping = false
            break;


          }


        }

      }
    }

  }

}


// tiled  platformer side collision



function TopTiledCollider(lname, obj) {

  if (loader)

    data.layers.forEach(function (layer) {
      if (layer.type == "objectgroup") {
        if (layer.name == lname)

          layer.objects.forEach(function (ob) {
            const body = obj.collider
            if (canDraw(ob, camera)) {
              if (obj.vy > 0)

                if (obj.collider.x + obj.collider.w >= ob.x && obj.collider.y + obj.collider.h + obj.vy >= ob.y &&
                  obj.collider.x <= ob.x + ob.width && obj.collider.y + obj.vy <= ob.y + ob.height && obj.y < ob.y) {
                  obj.vy = 0

                  obj.onFloor = true
                  const offset = body.y - obj.y + body.h

                  obj.y = ob.y - offset - 0.01
                  //obj.collider.y = ob.y - obj.collider.h - 0.01 //ob.y - obj.h - 0.01

                  if (obj.vy == 0) {
                    if (obj.shape == "circle")
                      shadowY = shadowY - 27
                    if (obj.shape == "rect")
                      shadowY = shadowY - 33
                  }




                  JumpTime = 0
                  onFloor = true
                  obj.onFloor = true
                  return;
                }

            }

          })

      }


    })


}






function BottomTiledCollider(lname, obj) {
  if (loader)
    data.layers.forEach(function (layer) {
      if (layer.type == "objectgroup") {
        if (layer.name == lname)
          layer.objects.forEach(function (ob) {

            const body = obj.collider


            if (canDraw(ob, camera)) {
              if (isJumping && obj.vy < 0 && (body.x - obj.vx) + body.w > ob.x - obj.vx && body.y + body.h >= ob.y &&
                body.x - obj.vx <= ob.x + ob.width - obj.vx && body.y <= ob.y + ob.height && body.y + body.h > ob.y + ob.height) {

                obj.vy = 0
                const offset = body.y - obj.y
                obj.y = (ob.y + ob.height - 7) - offset + 9  //ob.y + ob.height
                obj.collider.y = ob.y + ob.height - offset + 9
                obj.onFloor = false
                return

              }
            }

          })

      }


    })

}



function LeftTiledCollider(lname, obj) {
  if (loader)
    data.layers.forEach(function (layer) {
      if (layer.type == "objectgroup") {
        if (layer.name == lname)
          layer.objects.forEach(function (ob) {

            const body = obj.collider


            if (isCollide(body, ob)) {
              if (obj.vx > 0) {
                const offset = body.x - obj.x + body.w

                obj.x = ob.x - offset - 0.01
                obj.collider.x = obj.x + obj.collider.w / 2

                return obj.vx = 0

              }


            }


          })

      }

    })
}




function RightTiledCollider(lname, obj) {
  if (loader)
    data.layers.forEach(function (layer) {
      if (layer.type == "objectgroup") {
        if (layer.name == lname)
          layer.objects.forEach(function (ob) {
            const body = obj.collider


            if (isCollide(body, ob)) {

              if (obj.vx < 0) {
                const offset = body.x - obj.x
                obj.x = ob.x + ob.width - offset + 0.01


                return

              }



            }

          })

      }

    })
}




//1d to 2d Array
Array.prototype.parse2D = function (size) {
  var result = []

  for (var i = 0; i < this.length; i += size) {
    result.push(this.slice(i, i + size))

  }

  return result

}


function isFlipCollide(a, b) {
  var dx = Math.abs(a.x - (b.x));
  var dy = Math.abs(a.y - (b.y));


  if (b.r) {

    if (a.flipX && a.x + a.w > b.x && a.x - a.w * 1.5 <= b.x + b.r * 1.5 &&
      a.y + a.h > b.y && a.y < b.y + b.r * 1.8 ||
      dx < b.r + a.w && dy < b.r + a.h) {
      if (a.flipX && a.x < b.x + b.r / 1.8) { return }
      return true

    }


    if (!a.flpiX && a.x + a.w / 1.5 > b.x && a.x < b.x + b.r &&
      a.y + a.h > b.y && a.y < b.y + b.r / 1.8 ||
      dx < b.r + a.w && dy < b.r + a.h
    ) {
      return true

    }



  }
  if (b.r == undefined) {
    var dx = Math.abs(a.x - (b.x));
    var dy = Math.abs(a.y - (b.y));


    if (!a.flipX && a.x + a.w >= b.x && a.x <= b.x + b.w &&
      a.y + a.h >= b.y && a.y <= b.y + b.h * 1.8) {
      return true
    }

    if (a.flipX && a.x + a.w >= b.x && a.x - a.w * 1.8 <= b.x + b.w &&
      a.y + a.h >= b.y && a.y <= b.y + b.h * 1.8
    ) {
      if (a.flipX && a.x < b.x + b.w) { return }
      return true
    }

  }

}




var partImage = new Image()
function Particles(x, y, size, target, name, isRpg) {

  this.name = name || "rainbow"

  this.speed = (Math.random() * 3) - 2

  this.angle = Math.random() * Math.PI * 3
  this.x = x + size / 2
  this.y = y + 5
  this.size = (size / 1.5) * self.scale
  this.alpha = 1
  this.speed = (Math.random() * 1.5) - 2
  this.friction = 0.95
  this.vx = Math.cos(this.angle) * this.speed
  this.vy = Math.sin(this.angle) * this.speed




  this.update = function () {

    this.vx *= this.friction + 0.3
    this.vy *= this.friction + 0.3
    this.x += this.vx
    this.vy -= 0.5
    if (frame % 4 === 0)
      this.y += this.vy

    if (this.name == "fire") {
      this.color = "#720"
      this.speed = 3
      this.vx = Math.cos(this.angle) * this.speed
      this.vy = Math.sin(this.angle) * this.speed
      this.y += this.vy * this.friction
      this.vx *= this.friction

    }


    else if (this.name == "dust") {
      this.vx = (Math.random() * -0.5)
      this.vy = (Math.random() + 2.2) * Math.random() * (-2) //(Math.random()*(-7)) + 4
      if (!target.onFloor) { return }
      this.color = "lightgray"
      this.vy += 1.5 + 0.1
      this.y = target.y + target.h - 0.4
      this.y += this.vy * 0.9
      this.size = 0.8

      if (target.vx > 0 && !isJumping) {
        this.x -= 0.5 + (Math.random() * 0.2 * self.scale)
      } else if (target.vx > 0 && isJumping) {
        this.x -= 0.5 + (Math.random() * 0.2 * self.scale)
      }

      else if (target.vx < 0 && !isJumping) {

        this.x -= (Math.random() * 0.3) - 5
      } else if (target.vx < 0 && isJumping) {
        this.x -= (Math.random() * 3) - 5
      }


      else if (target.vy > 0 && !isJumping) {
        this.y += (Math.random() * -5)

      }

      else if (target.vy < 0 && !isJumping) {
        this.y -= (Math.random() * -5)

      }


    }


    else if (this.name == "rainbow") {
      this.color = "#" + (Math.random().toString(16).substr(-6));
      this.speed = 2
      this.vx = Math.cos(this.angle) * this.speed
      this.vy = Math.sin(this.angle) * this.speed

      this.y += this.vy * this.friction
      this.vx *= this.friction
    }
    
    else if (this.name == "self") {
      this.color = target.color
      this.speed = 1.8
      this.vx = Math.cos(this.angle) * this.speed
      this.vy = Math.sin(this.angle) * this.speed
    
      this.y += this.vy * this.friction
      this.vx *= this.friction
    }


    else if (this.name == "waterfall") {

      this.y -= this.vy * this.friction * 2

      this.color = "rgba(200,200,200,0.4)"


    }

    else if (this.name == "blood") {

      this.color = "rgba(255,000,000,1)"

      this.y -= this.vy
      this.size = (Math.random() * 0.95 + 0.03) * self.scale
    }

    else if (this.name == "poison") {

      this.color = "rgba(205,80,255,0.8)"
      this.friction = 0.4
      this.vx *= this.friction
      this.vy -= 0.5
      this.y += this.vy
      this.x += this.vx

    }



    else if (this.name == "smoke") {
      this.color = "rgba(0,0,0,1)"
      this.friction = 0.4
      this.vx *= this.friction
      this.vy -= 0.5
      this.y += this.vy
      this.x += this.vx
    } else {
      if (target.color) {
        this.color = target.color //"#"+(Math.random().toString(16).substr(-6));
      }

    }


  }


  this.draw = function () {

    if (frame % 10 == 0 && this.name != "dust") {

      for (let i = 0; i < particles.length; i++) {
        var part = particles[i]
        part.dx = target.x - part.x
        part.dy = target.y - part.y
        if (particles.length >= 330 && this.name != "dust") {
          particles.length = 330
        }


        var distance = Math.hypot(part.dy, part.dx)

        if (this.name != 'dust' && distance >= 20) {
          this.alpha -= 0.1

          if (this.alpha <= 0.1) {
            if (particles[0]) {
              this.alpha = 1
            }
            kill(particles, i)
          }


        }

      }
    } else if (frame % 2 == 0 && this.name == "dust") {

      for (let i = 0; i < particles.length; i++) {
        var part = particles[i]
        part.dx = target.x - part.x
        part.dy = target.y - part.y


        var distance = Math.hypot(part.dx, part.dy)


        if (distance >= 2 && this.name == "dust") {
          this.alpha -= 0.05

          if (this.alpha <= 0.3) {
            if (particles[0]) {
              this.alpha = 1
            }
            kill(particles, i)
          }


        }


      }


    }



    if (target.image && this.name == "self") {
      this.vx *= this.friction
      this.x += this.vx
      this.y += this.vy
      partImage.src = target.image.src
      ctx.save()
      ctx.globalAlpha = this.alpha
      if (canDraw(target, camera)) {
          if(target.type =="polygon"){
           ctx.drawImage(partImage, this.x , this.y , (this.size * 2.5), (this.size * 2.5))
          }else
        ctx.drawImage(partImage, this.x * self.scale, this.y * self.scale, (this.size * 2.5), (this.size * 2.5))

      }
      ctx.restore()
      return
    } else {


      ctx.save()
      ctx.globalAlpha = this.alpha
      ctx.fillStyle = this.color
      if (this.name == "fire") {
        ctx.shadowBlur = 4
        ctx.shadowColor = 'rgba(240,200,10,0.8)'
      } else {
        ctx.shadowColor = this.color
      }

      if (canDraw(target, camera)) {
        if (this.name != "poison") {
           if(target.type =="polygon"){
             ctx.fillRect(this.x , this.y , (this.size * Math.random() * 4 + 0.3), (this.size * Math.random() * 4 + 0.3))
             
           }else
          ctx.fillRect(this.x , this.y , (this.size * Math.random() * 4 + 0.3), (this.size * Math.random() * 4 + 0.3))
        }



        if (this.name == "poison") {

          ctx.beginPath()
          if(target.type =="polygon"){
            ctx.beginPath()
             ctx.arc(this.x , this.y , (this.size * Math.random() * 2 + 0.2), 1.2, Math.PI * 2)
             ctx.fill()
             ctx.closePath()
             
          }else
          ctx.beginPath()
          ctx.arc(this.x * self.scale, this.y * self.scale, (this.size * Math.random() * 2 + 0.2), 1.2, Math.PI * 2)
          ctx.fill()
          ctx.closePath()
        }
        ctx.restore()
      }

    }
  }

}


function createParticle(target, thesize, name, isRpg) {
  this.thesize = thesize
  if (this.thesize > 15) {
    this.thesize = 15
  }
  this.target = target
  for (var i = 0; i < thesize; i++) {
    if (target.image) {

      if (canDraw(this.target, camera) && target.onFloor) {
        particles.push(new Particles(target.x || target.x, target.y, (Math.random() * 3 + 0.3), target, name))
      }
    }
    if (name == "fire" || name == "waterfall" || name == "smoke" || name == "rainbow" && name != "dust") {
      if (canDraw(this.target, camera)) {

        particles.push(new Particles(target.x + target.w / 2 || target.x, target.y, (Math.random() * 1.5 + 0.2), target, name))
      }
    }
    else if (name == "dust" && target.onFloor && canDraw(this.target, camera)) {
      particles.push(new Particles(target.x + target.w / 2 || target.x, target.y, (Math.random() * 2 + 0.2), target, name))

    }
    else {
      if (canDraw(this.target, camera) && name != "dust") {
        particles.push(new Particles(target.x + target.w / 2 || target.x, target.y, (Math.random() * 3 + 0.2), target, name))
      }
    }


  }

  return this
}







function hitBox(a, b, gap) {
  var dx = (a.x - b.x)
  var dy = (a.y - b.y)
  var dist = Math.hypot(dx, dy)
  if (dist <= gap) {
    if (a.left && b.x > a.x) { return false }
    if (!a.left && b.x < a.x) { return false }
    return true
  }
  return false
}


function SnowEffect(space) {
  num = [1, -3]
  rand = Math.random() * num.length

  this.space = space
  var cs = {
    x: Math.ceil(Math.random() * camera.width) + camera.x,
    y: 0,
    s: Math.floor(Math.random() * 1) + 0.5,
    color: `rgb(255,255,255)`
  }

  for (var i = 0; i < 5; i += 2) {
    snows.push(new Circle(cs.x, cs.y, cs.s, Math.cos(num[rand]), Math.floor(Math.random() * 0.2) + 1, cs.color))
  }

  for (var j = 0; j < snows.length; j++) {
    snow = snows[j]
    snow.y += 3
    if (snow.y > space.height || snow.x > space.width) {
      kill(snows, j)
    }
  }
}


function RainEffect(space) {
  this.space = space
  var num = [-1, 3]

  var cr = {
    x: Math.floor(Math.random() * camera.width) + camera.x,
    y: 0,
    w: Math.floor(Math.random() * 0.2) + 0.05 * 8,
    h: 8,
    color: `rgba(250,250,250,0.07)`
  }


  for (var i = 0; i < 50; i += 2) {

    rand = Math.random() * num.length
    rains.push(new Sprite(cr.x, cr.y, cr.w, cr.h, Math.cos(num[rand]), Math.floor(Math.random() * 3) + 5, cr.color))
  }


  rains.forEach(function (rain, k) {
    rain.y += 30

    if (rain.y > space.height) {
      kill(rains, k)

    }
    if (rains.x > space.width) {
      kill(rains, k)
    }


  })



}



function isPath(a, b, c) {
  index = 0
  var gapx = Math.abs(c.x - b.x)
  var gapy = Math.abs(c.y - b.y)
  wp = a[pathIndex]

  dx = (wp.x - b.x)
  dy = (wp.y - b.y)
  var angle = Math.atan2(dy, dx)

  var dist = Math.hypot(gapx, gapy)


  b.vx = Math.cos(angle)
  b.vy = Math.sin(angle)
  b.x += b.vx * 2
  b.y += b.vy * 2

  if (dist >= -5 && dist <= 150) {

    if (Math.abs(Math.round(b.x) - Math.round(wp.x)) < Math.abs(b.vx * 2) &&
      Math.abs(Math.round(b.y) - Math.round(wp.y)) < Math.abs(b.vy * 2) &&
      pathIndex < a.length - 1) {

      return true
    } else {
      return false
    }


  }


}





